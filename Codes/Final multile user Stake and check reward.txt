// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;
interface IERC20{
    function transfer(address receiver , uint256 trantoken) external returns(bool);
    function transferfrom(address owner, address recetoken,uint256 value) external returns(bool);
}
contract ERC_Staking{

    event StakeEvent(uint256 amount, uint256 Time);

    mapping( address=>uint256) TotalRewards;
    mapping( address=>uint256) ReceivedReward;
    mapping( address=>uint256) Reward_calculate;

    mapping( address=>bool) stakechecking;

    uint256 MaxRewards;
    uint256 PerRewards;

    IERC20 public Token;
    constructor(IERC20 _Token)
    {
    Token=_Token;
    }

    struct User_detail{
        uint256 deposit_Amount;
        uint256 totalReward;
        uint256 pendingReward;
        uint256 withdrawReward;
        uint256 depositTime;
        uint256 withdrawTime;
    }
    mapping(address => User_detail) public User_data;

    function Stakes(uint256 StakeAmount) public
    {
        if(stakechecking[msg.sender]==false)
        { 
            User_data[msg.sender].deposit_Amount = StakeAmount;
            User_data[msg.sender].depositTime = block.timestamp;
            Token.transferfrom(msg.sender, address(this), StakeAmount);
            stakechecking[msg.sender]=true;
            
            Reward_calculate[msg.sender] = User_data[msg.sender].deposit_Amount/100;
            User_data[msg.sender].totalReward = Reward_calculate[msg.sender] * 360;

             User_data[msg.sender].pendingReward = User_data[msg.sender].totalReward;

            emit StakeEvent(StakeAmount, block.timestamp);
        }
        else
        {
        require (stakechecking[msg.sender]!=true, "Alreday Stake");
        }
    }
    uint256 a;
    function CheckRewards() public  view returns (uint256 )
    {
        uint256 RewardPerSecond;
        uint256 RewardAfter_Delay;
        uint256 Time_Diff; 
        uint b;
        uint256 MaxReward;

        RewardPerSecond = User_data[msg.sender].totalReward/300;
        RewardAfter_Delay = RewardPerSecond * 30;

           if(block.timestamp >= User_data[msg.sender].depositTime + 5 minutes)
           { 
            MaxReward =  User_data[msg.sender].totalReward;
           }
           else
           {
                Time_Diff= block.timestamp - User_data[msg.sender].depositTime;
                b = Time_Diff/30;
                MaxReward = RewardAfter_Delay * b;
           }

          MaxReward= MaxReward - User_data[msg.sender].withdrawReward;

        return MaxReward;
    }
    function WithDraw () public
    {
        TotalRewards[msg.sender] = CheckRewards();
        Token.transfer(msg.sender, TotalRewards[msg.sender]);

        if(ReceivedReward[msg.sender]!=TotalRewards[msg.sender])
        { 
            ReceivedReward[msg.sender] += TotalRewards[msg.sender]; 
        }
        else
        { 
            require (ReceivedReward[msg.sender]!=TotalRewards[msg.sender],"Reward Already transferred"); 
        }

        User_data[msg.sender].pendingReward = User_data[msg.sender].totalReward - ReceivedReward[msg.sender];
        User_data[msg.sender].withdrawReward = ReceivedReward[msg.sender];
        User_data[msg.sender].withdrawTime = block.timestamp;
    
    }
    function UnStakes() public  
    {
        if(stakechecking[msg.sender]==true)
        {
        Token.transfer(msg.sender, User_data[msg.sender].deposit_Amount);
        User_data[msg.sender].deposit_Amount=0;
        stakechecking[msg.sender]=false;
        }
        else
        {
           require (stakechecking[msg.sender]!=false, "Alreday UnStake"); 
        }
    }

}