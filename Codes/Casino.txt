pragma solidity 0.8.16;
// SPDX-License-Identifier: MIT
library SafeMath {
    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b);
        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;
        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);
        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function _msgsender() external view returns (address);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    // event Transfer(address indexed from, address indexed to, uint256 value);
    // event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Crash_Casino_Game {
    using SafeMath for uint256;
    address public Owner; 
    uint256 public Random_Number;
    
    address[] public playerBet;
    mapping (address => mapping (uint256 => uint256)) private betAmount;
    mapping (address => uint256) private countBetAmount;
    mapping (address => mapping (uint256 => uint256)) private linePoint;
    mapping (address => bool) private c_address;
    uint256 public totalBetAmount;
    uint256 public contractbalance_P;
    
    uint256 public taxPercentage;
    address public taxAddress;
    address public devAddress;
    mapping (address => mapping (uint256 => uint256)) private betAmountAfterTax;
    mapping (address => mapping (uint256 => uint256)) private rewardAmount;
    
    uint256 private TaxFee;
    uint256 private devTax;
    uint256 private StartTime;
    uint256 private DelayTime;
    uint256 private MaxRendomNumber;
    bool private _PGame;
    uint256 private Day;
    uint256 private GamePlayTime;
    bool private balanceBool;
    uint256 public balance; 
    uint256 public _afterCapped;
    bool public allow;
    IERC20 public Token;
    constructor(IERC20 _Token)
    {
        Token =_Token;
        TaxFee = 3;
        devTax= 5;
        contractbalance_P = 2;
        StartTime = block.timestamp;
        DelayTime = 10 minutes;
        MaxRendomNumber = 30;
        // taxAddress = 0x617F2E2fD72FD9D5503197092aC168c91465E7f2;
        // devAddress= 0x17F6AD8Ef982297579C203069C1DbfFE4348c372;
        taxAddress = 0xea571fd77B6C5A8cBC9D64017d95Cc757a73b353;
        devAddress= 0xF18C26Bf1d0E6787B2ec0E7eD24F0ADd4F415d64;

        Owner = msg.sender;
        allow = true;
    }
    modifier OnlyOwer{
        require(Owner == msg.sender);
        _;
    }
    //Public funxtion
    function Public(bool _bool) public
    {
        allow = _bool;
    }
    // Set tax Fee
    function SetTax(uint256 _tax) 
    public 
    OnlyOwer
    {TaxFee = _tax;}

    function SetDevTax(uint256 _tax) 
    public 
    OnlyOwer
    {devTax = _tax;}

    function checkBalance() internal 
    {
        balance = Token.balanceOf(address(this));
        _afterCapped = (balance.mul(contractbalance_P)).div(100);
    }
    function checkAddress(address _address) internal{
        
            playerBet.push(_address); 
            c_address[_address] = true; 
    }
    // Place Bet
    function Bet(uint256 _betamount, uint256 _linepoint)
    public 
    {
        require(allow == true, "Not allowed playing");
        require(block.timestamp <= StartTime.add(DelayTime).add(Random_Number), "Bet time is completed");
        if(!balanceBool)
        {
            checkBalance();
            balanceBool = true;
        }
        require(totalBetAmount <= _afterCapped, "The contract balance is less than the bet Amount");

        betAmount[msg.sender][countBetAmount[msg.sender]] = _betamount;
        linePoint[msg.sender][countBetAmount[msg.sender]] = _linepoint;
        totalBetAmount += _betamount;

        if(!c_address[msg.sender])
        { checkAddress(msg.sender);}

        taxPercentage = (_betamount.mul(TaxFee)).div(100);
        Token.transferFrom(msg.sender,taxAddress, taxPercentage);
        
        _betamount = _betamount.sub(taxPercentage);
        betAmountAfterTax[msg.sender][countBetAmount[msg.sender]] = _betamount;
        Token.transferFrom(msg.sender, address(this), _betamount);
        countBetAmount[msg.sender] += 1;
    }
    // Reward Function
    function RandomN_Generate() public OnlyOwer
    {
        require(block.timestamp >= StartTime.add(DelayTime), "Bet time is not completed");
        // require(!_PGame, "Already number Generated");
        Random_Number = uint256(keccak256(abi.encodePacked(block.timestamp,block.difficulty,  
        msg.sender))) % MaxRendomNumber;
        GamePlayTime = block.timestamp;
        // _PGame = true;
    }
    // Reward Winning fuction
    function Winner_Rewards() public OnlyOwer
    {
        require(allow == true, "Not allowed playing");
        uint256 _tax_P;
        require(block.timestamp > GamePlayTime.add(Random_Number), "");
        for(uint256 i=0; i < playerBet.length ;i++)
        {
            for(uint256 j=0; j< countBetAmount[playerBet[i]]; j++)
                {
                    if(linePoint[playerBet[i]][j] <= Random_Number)
                    {
                    rewardAmount[playerBet[i]][j] = betAmountAfterTax[playerBet[i]][j].mul(linePoint[playerBet[i]][j]);
                    _tax_P = (rewardAmount[playerBet[i]][j].mul(devTax)).div(100);
                    rewardAmount[playerBet[i]][j] -= _tax_P;
                    Token.transfer(playerBet[i], rewardAmount[playerBet[i]][j]);
                    Token.transfer(devAddress, _tax_P);
                    }
                betAmountAfterTax[playerBet[i]][j] = 0;
                betAmount[playerBet[i]][j] = 0;
                linePoint[playerBet[i]][j] = 0;
                }
            countBetAmount[playerBet[i]] = 0;
            c_address[playerBet[i]] = false;
        }

        totalBetAmount = 0;
        _PGame = false;
        StartTime = block.timestamp;
        balanceBool= false;
        delete playerBet;

    }

    /// Profit
    function Profit() public view returns(uint256)
    {
        uint256 _balance = Token.balanceOf(address(this));
        uint256 _profit = _balance.sub(balance);
        return _profit;
    }
    // Withdraw
    function Withdraw(uint256 amount) public OnlyOwer
    {
        // uint256 balance_ = Token.balanceOf(address(this));
        // amount = balance_.sub(amount);
        Token.transfer(Owner, amount);
    }
    function BNBq() public payable returns (uint256)
    {
        return msg.value;
    }
}