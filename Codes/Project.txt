// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

library SafeMath {
    /**
     * @dev Multiplies two unsigned integers, reverts on overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b);
        return c;
    }

    /**
     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    /**
     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;
        return c;
    }

    /**
     * @dev Adds two unsigned integers, reverts on overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);
        return c;
    }

    /**
     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
     * reverts when dividing by zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IPancakeRouter01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}


contract ULE_BUY is Ownable {

    using SafeMath for uint256;
    IERC20 public ULE;
    IPancakeRouter01 public Router;
    address public WETH;

    uint256 public firstPoolPercentage = 40;
    uint256 public secondPoolPercentage = 40;
    uint256 public thirdPoolpercentage = 20;


    constructor(IERC20 _ULE_, IPancakeRouter01 _Router)
    {
       ULE = _ULE_;
       Router = _Router;
       WETH = Router.WETH();
    }
    uint256 otherhalf;
    uint256 half;
    uint256 public FirstPoolBNBAmount;
    uint256 public SecondPoolTokenAmount;
    uint256 public SecondPoolBNBAmount;
    uint256 public ThirdPoolBNBAmount;
    uint256 public FirstPoolBNBLiquidity = 5000000000000000;
    uint256 public SecondPoolULELiquidity = 100000000000000000000;
    uint256 public ThirdPoolBNBLiquidity = 3000000000000000;

    function Buy(uint256 _tokens) public payable {
        ULE.transferFrom(_msgSender(),address(this),_tokens);
        uint256 BNBamount = msg.value;
        uint256 firstPoolBNBAmount = (BNBamount.mul(firstPoolPercentage)).div(100);
        uint256 secondPoolULEAmount = (_tokens.mul(secondPoolPercentage)).div(100);
        uint256 thirdPoolBNBAmount = (BNBamount.mul(thirdPoolpercentage)).div(100);

        FirstPoolBNBAmount += firstPoolBNBAmount;
        SecondPoolTokenAmount += secondPoolULEAmount;
        ThirdPoolBNBAmount += thirdPoolBNBAmount;

        if(FirstPoolBNBAmount >= FirstPoolBNBLiquidity)
        {
        half = FirstPoolBNBAmount.div(2);
        swapExactETHForTokens(half);
        otherhalf = otherhalf - half;
        uint256 tokenAmount = ULE.balanceOf(address(this));
        ULE.approve(address(Router), tokenAmount);
        addLiquidity(tokenAmount ,otherhalf);
        }
        // otherhalf = 0;
        // if(ThirdPoolBNBAmount == ThirdPoolBNBLiquidity)
        // {
        // half = ThirdPoolBNBAmount.div(2);
        // swapExactETHForTokens(half);
        // otherhalf = otherhalf - half;
        // uint256 tokenAmount = address(this).balance;
        // addLiquidity(tokenAmount ,otherhalf);
        // }
        // otherhalf = 0;
        // if(SecondPoolTokenAmount == SecondPoolULELiquidity)
        // {
        // half = SecondPoolTokenAmount.div(2);
        // uint256 initialBalance = address(this).balance;
        // swapTokensForEth(half);
        // otherhalf = otherhalf - half;
        // uint256 newBalance = address(this).balance.sub(initialBalance);
        // addLiquidity(newBalance ,otherhalf);
        // }

        // uint256 tokenAmount = ULE.balanceOf(address(this));
        // ULE.approve(address(Router), tokenAmount);

        // }
        // if(SecondPoolTokenAmount == SecondPoolULELiquidity){

        // }

        // if(ThirdPoolBNBAmount == ThirdPoolBNBLiquidity){

        // }
        
    }

    function swapExactETHForTokens(uint256 ethAmount) public payable {
    address[] memory path = new address[](2);
    path[0] = Router.WETH();
    path[1] = address(ULE);
    Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(
      0, 
      path,
      address(this), 
      block.timestamp
    );
  }
    function addLiquidity(uint256 _amount, uint256 ethAmount) public payable{
      Router.addLiquidityETH{value: ethAmount}(
          address(ULE),
          _amount,
          0,
          0,
          address(this),
          block.timestamp
      );      
  }   
  function swapTokensForEth(uint256 tokenAmount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = Router.WETH();

        ULE.approve(address(Router), tokenAmount);
        // make the swap
        Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }
    
    function withdraw() public 
    {
        payable(msg.sender).transfer(address(this).balance);
    }
    function getEther () public payable
    {

    }
}